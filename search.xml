[{"title":"光线与不同几何求交","url":"http://example.com/2023/07/27/光线与几种基本几何的求交/","content":"<h3 id=\"光线与二维几何求交\">1. 光线与二维几何求交</h3>\r\n<h3 id=\"光线与平面求交\">1) 光线与平面求交</h3>\r\n<figure>\r\n<img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/23-7-26.png\"\r\nalt=\"23-7-26\" />\r\n<figcaption aria-hidden=\"true\">23-7-26</figcaption>\r\n</figure>\r\n<p><span class=\"math display\">\\[\r\n\\begin{cases}\\bold P=\\bold o+t\\cdot\\bold d\\\\\\\\\\bold n\\cdot(\\bold P-\\bold\r\nP&#39;)=0\\end{cases}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n\\left[\r\n\\matrix{\r\n  1 &amp; -1 &amp; 1 &amp; 1\\\\\r\n0 &amp; 1 &amp; -1 &amp; -1\\\\\r\n  1 &amp; 1 &amp; -1 &amp; 0\\\\\r\n  -1 &amp; 0 &amp; 1 &amp; 0\\\\\r\n  1 &amp; 1 &amp; ? &amp; -1\r\n}\r\n\\right]\r\n\\]</span> <span class=\"math display\">\\[\r\nT_{1}（x）=\\begin{cases} 1，X_{1} &lt; 6.24 \\\\ -1， X_{1} &gt;=\r\n8.91\\end{cases}\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(e^{i \\pi} +1 = 0\\)</span></p>\r\n<span class=\"math inline\">\\(A \\\\ B\\)</span> 错误写法\r\n<span class=\"math display\">\\[\\begin{split} A\\\\B \\end{split}\\]</span>\r\n<p>写在行内错误，写在行间正确。</p>\r\n","categories":[],"tags":[]},{"title":"《Ray Tracing in One Weekend》 note-1","url":"http://example.com/2023/07/26/《Ray Tracing in One Weekend》note-chart1-2/","content":"<h1 id=\"chart1-2\">chart1-2</h1>\r\n","categories":[],"tags":[]},{"title":"【Vulkan+Qt】","url":"http://example.com/2023/07/26/【Vulkan+Qt】/","content":"<p>欢迎使用 <strong>{小书匠}(xiaoshujiang)编辑器</strong>，您可以通过\r\n<code>小书匠主按钮&gt;模板</code> 里的模板管理来改变新建文章的内容。</p>\r\n<p><strong>参考链接</strong> <a\r\nhref=\"https://www.bilibili.com/read/cv268059\">enter description\r\nhere</a></p>\r\n","categories":["/小书匠/日记/2022-03"],"tags":["新建,模板,小书匠"]},{"title":"【Vulkan】将最终绘制结果导出并存储为图片","url":"http://example.com/2023/07/26/【Vulkan】将最终绘制结果导出并存储为图片/","content":"<p>如何将vulkan中绘制的结果导出，并且存储为文件格式？</p>\r\n<h2\r\nid=\"opengl中将绘制结果存储为图片的方法\">OpenGL中将绘制结果存储为图片的方法</h2>\r\n<p>GPU渲染的结果保存在显存(帧缓存)中，想要将保存在显存中的结果转存到内存，在opengl中需要用到glReadPixels这个函数。\r\n<strong>glReadPixels：</strong>\r\n把已经绘制好的像素（它可能已经被保存到显卡的显存中）读取到内存。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> glReadPixels（GLint x, </span><br><span class=\"line\">\t\t\t\t\tGLint y,       \t   → 左下角坐标</span><br><span class=\"line\">\t\t\t\t\tGLsizei width,</span><br><span class=\"line\">\t\t\t\t\tGLsizei height,    → 前四个参数描述了一个矩形范围</span><br><span class=\"line\">\t\t\t\t\tGLenum format,     → 像素存储的格式</span><br><span class=\"line\">\t\t\t\t\tGLenum type,   \t   → 像素数据的数据类型</span><br><span class=\"line\">\t\t\t\t\tGLvoid * data）;   →返回像素数据</span><br></pre></td></tr></table></figure>\r\n<p><strong>实现过程：</strong> step 1：申请一块放置读取到像素的内存\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RGBColor* ColorBuffer = <span class=\"keyword\">new</span> RGBColor[WindowSizeX * WindowSizeY];</span><br></pre></td></tr></table></figure> step 2：从显存中读取像素 <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">glReadPixels</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, WindowSizeX, WindowSizeY, GL_BGR, GL_UNSIGNED_BYTE, ColorBuffer);</span><br></pre></td></tr></table></figure> step\r\n3：将数据写入目标图片文件</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">WriteBMP</span>(<span class=\"string\">&quot;output.bmp&quot;</span>, ColorBuffer, WindowSizeX, WindowSizeY);</span><br></pre></td></tr></table></figure>\r\n<p>step 4：清理申请的内存</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">delete</span>[] ColorBuffer;</span><br></pre></td></tr></table></figure>\r\n<p><strong>注：</strong>\r\n这个存储的过程要放在OpenGL绘制结束后，在交换缓冲之前进行。</p>\r\n<p><strong>参考链接</strong> <a\r\nhref=\"https://blog.csdn.net/cd_yourheart/article/details/123528957\">双缓冲区模式下读取</a>\r\n<a\r\nhref=\"https://blog.csdn.net/u013412391/article/details/120565095\">将OpenGL渲染的结果保存为图片</a></p>\r\n<h2\r\nid=\"vulkan中将绘制结果存储为图片的方法\">Vulkan中将绘制结果存储为图片的方法</h2>\r\n<p><strong>VS opengl：</strong>\r\n基本过程一致，GPU中保存绘制结果的地方→分配得到的内存。但是，opengl中提供了glReadPixels函数，只需要调用这个函数就可以将绘制结果读取出来，但是vulkan中并没有提供直接的函数。</p>\r\n<p><strong>基本思路：</strong> vulkan中渲染结果放在swapchain\r\nimage中，程序中往往设定当前swapchain\r\nimage的数量为物理设备支持的最小swapchain\r\nimage数量+1,所以要在渲染完之后提交之前，将当前 Swap Chain Image\r\n的内容先存在一块申请的显存上，之后内存映射到内存中。</p>\r\n<p><strong>1. Format问题</strong> 当前物理设备支持的swapchain\r\nimage的格式为：VK_FORMAT_B8G8R8A8_SRGB\r\n申请到显存的设定格式：VK_FORMAT_R8G8B8A8_SRGB（创建image以及memory的代码如下）\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">createImage</span>(WIDTH, HEIGHT, <span class=\"number\">1</span>, VK_IMAGE_TYPE_2D, &gt;&gt;==VK_FORMAT_R8G8B8A8_SRGB==&lt;&lt;, VK_IMAGE_TILING_LINEAR, &gt;&gt;==VK_IMAGE_USAGE_TRANSFER_DST_BIT==&lt;&lt;</span><br><span class=\"line\">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, outputImg, outputImgMemory);</span><br></pre></td></tr></table></figure></p>\r\n<p><strong>2.Layout问题</strong> 当前swap chain\r\nImage的布局：VK_IMAGE_LAYOUT_PRESENT_SRC_KHR 作为transfer\r\nsource的布局：VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL\r\n申请到显存的布局：VK_IMAGE_LAYOUT_UNDEFINED 作为transfer\r\ndestination的布局：VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL\r\n支持内存映射的布局：VK_IMAGE_LAYOUT_GENERAL <strong>3.swap chain\r\nimage和output image之间布局的转换</strong> <mark>左图为swap chain\r\nImage的布局转换；右图为申请到的显存的布局转换</mark> <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD;</span><br><span class=\"line\">   VK_IMAGE_LAYOUT_PRESENT_SRC_KHR--&gt;VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;</span><br><span class=\"line\">   VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL--&gt;VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;</span><br><span class=\"line\"></span><br><span class=\"line\">VK_IMAGE_LAYOUT_UNDEFINED--&gt;VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL--&gt;VK_IMAGE_LAYOUT_GENERAL</span><br></pre></td></tr></table></figure>\r\n<strong>4.swap chain image和output image之间内容的copy</strong> step 1 →\r\nDevice 是否支持 blitting from optimal tiled images？ <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> supportsBlit = <span class=\"literal\">true</span>;</span><br><span class=\"line\">VkFormatProperties formatProperties;</span><br><span class=\"line\"><span class=\"built_in\">vkGetPhysicalDeviceFormatProperties</span>(physicalDevice, swapChainImageFormat, &amp;formatProperties);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!(formatProperties.optimalTilingFeatures &amp;  &gt;&gt;==VK_FORMAT_FEATURE_BLIT_SRC_BIT==&lt;&lt;))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstd::cerr &lt;&lt; <span class=\"string\">&quot;Device does not support blitting from optimal tiled images, using copy instead of blit!&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">\tsupportsBlit = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!(formatProperties.linearTilingFeatures &amp; &gt;&gt;==VK_FORMAT_FEATURE_BLIT_DST_BIT==&lt;&lt;)) &#123;</span><br><span class=\"line\">\tstd::cerr &lt;&lt; <span class=\"string\">&quot;Device does not support blitting to linear tiled images, using copy instead of blit!&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">\tsupportsBlit = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure> step\r\n2 → Device 支持 blitting from optimal tiled\r\nimages→<mark>vkCmdBlitImage</mark></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VkOffset3D blitSize;</span><br><span class=\"line\">blitSize.x = width;</span><br><span class=\"line\">blitSize.y = height;</span><br><span class=\"line\">blitSize.z = <span class=\"number\">1</span>;</span><br><span class=\"line\">VkImageBlit imageBlitRegion&#123;&#125;;</span><br><span class=\"line\">imageBlitRegion.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</span><br><span class=\"line\">imageBlitRegion.srcSubresource.layerCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">imageBlitRegion.srcOffsets[<span class=\"number\">1</span>] = blitSize;</span><br><span class=\"line\">imageBlitRegion.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</span><br><span class=\"line\">imageBlitRegion.dstSubresource.layerCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">imageBlitRegion.dstOffsets[<span class=\"number\">1</span>] = blitSize;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Issue the blit command</span></span><br><span class=\"line\"><span class=\"built_in\">vkCmdBlitImage</span>(</span><br><span class=\"line\">\tcommandBuffer,</span><br><span class=\"line\">\tsrcImage, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,</span><br><span class=\"line\">\toutputImg, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,</span><br><span class=\"line\">\t<span class=\"number\">1</span>,</span><br><span class=\"line\">\t&amp;imageBlitRegion,</span><br><span class=\"line\">\tVK_FILTER_NEAREST);</span><br></pre></td></tr></table></figure>\r\n<p>step 3 → Device 不支持 blitting from optimal tiled\r\nimages→<mark>vkCmdCopyImage</mark></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VkImageCopy imageCopyRegion&#123;&#125;;</span><br><span class=\"line\">imageCopyRegion.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</span><br><span class=\"line\">imageCopyRegion.srcSubresource.layerCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">imageCopyRegion.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</span><br><span class=\"line\">imageCopyRegion.dstSubresource.layerCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">imageCopyRegion.extent.width = width;</span><br><span class=\"line\">imageCopyRegion.extent.height = height;</span><br><span class=\"line\">imageCopyRegion.extent.depth = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Issue the copy command</span></span><br><span class=\"line\"><span class=\"built_in\">vkCmdCopyImage</span>(</span><br><span class=\"line\">\tcommandBuffer,</span><br><span class=\"line\">\tsrcImage, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,</span><br><span class=\"line\">\toutputImg, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,</span><br><span class=\"line\">\t<span class=\"number\">1</span>,</span><br><span class=\"line\">\t&amp;imageCopyRegion);</span><br></pre></td></tr></table></figure>\r\n<p><strong>5. 进行内存映射，将显存的内容映射到内存</strong> step 1 →\r\n找到subresource 图像数据的起始 offset <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VkImageSubresource subResource&#123; VK_IMAGE_ASPECT_COLOR_BIT, <span class=\"number\">0</span>, <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">VkSubresourceLayout subResourceLayout;</span><br><span class=\"line\"><span class=\"built_in\">vkGetImageSubresourceLayout</span>(logicalDevice, outputImg, &amp;subResource, &amp;subResourceLayout);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Map image memory so we can start copying from it</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* data;</span><br><span class=\"line\">&gt;&gt;==vkMapMemory==&lt;&lt;(logicalDevice, outputImgMemory, <span class=\"number\">0</span>, VK_WHOLE_SIZE, <span class=\"number\">0</span>, (<span class=\"keyword\">void</span>**)&amp;data);</span><br><span class=\"line\">data += subResourceLayout.offset;</span><br></pre></td></tr></table></figure> <strong>6.\r\n将data数据以ppm格式存入</strong> <mark>注意点：</mark> 若swapchain\r\nimage格式为BGR，目标存储格式为RGB，则需要手动转换color components</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (colorSwizzle</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">auto</span> a = (<span class=\"keyword\">char</span>*)row;</span><br><span class=\"line\">\t\t<span class=\"keyword\">auto</span> b = (<span class=\"keyword\">char</span>*)(row+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">auto</span> c = (<span class=\"keyword\">char</span>*)(row+<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\tfile.<span class=\"built_in\">write</span>((<span class=\"keyword\">char</span>*)row + <span class=\"number\">2</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tfile.<span class=\"built_in\">write</span>((<span class=\"keyword\">char</span>*)row + <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tfile.<span class=\"built_in\">write</span>((<span class=\"keyword\">char</span>*)row, <span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\r\n<p><strong>参考链接：</strong> <a\r\nhref=\"https://gavinkg.github.io/ILearnVulkanFromScratch-CN/mdroot/Vulkan%20%E8%BF%9B%E9%98%B6/%E6%88%AA%E5%8F%96%E5%B1%8F%E5%B9%95/%E5%8E%9F%E7%90%86.html\">截屏原理</a>\r\n<a\r\nhref=\"https://github.com/SaschaWillems/VulkanCapsViewer/blob/master/vulkancapsviewer.cpp\">代码参考</a></p>\r\n","categories":["/personal blog/vulkan/2022-03"],"tags":["vulkan,OpenGL"]},{"title":"Hello World","url":"http://example.com/2023/07/26/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very\r\nfirst post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for\r\nmore info. If you get any problems when using Hexo, you can find the\r\nanswer in <a\r\nhref=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or\r\nyou can ask me on <a\r\nhref=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\r\n<h2 id=\"quick-start\">Quick Start</h2>\r\n<h3 id=\"create-a-new-post\">Create a new post</h3>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\r\n<p>More info: <a\r\nhref=\"https://hexo.io/docs/writing.html\">Writing</a></p>\r\n<h3 id=\"run-server\">Run server</h3>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\r\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\r\n<h3 id=\"generate-static-files\">Generate static files</h3>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\r\n<p>More info: <a\r\nhref=\"https://hexo.io/docs/generating.html\">Generating</a></p>\r\n<h3 id=\"deploy-to-remote-sites\">Deploy to remote sites</h3>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\r\n<p>More info: <a\r\nhref=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\r\n","categories":[],"tags":[]},{"title":"GitHub Page 搭建个人主页","url":"http://example.com/2023/07/26/2022-03-17未命名文件/","content":"<p><strong>github Pages——用户编写的、托管在github上的静态网页</strong>\r\n## Create Personal Repositories\r\n++repository是一个存放项目文件的仓库，之后博客源码和hexo发布后的静态HTML文件全部保存在里面。++</p>\r\n<ol type=\"1\">\r\n<li><p>登录自己的github账号 <img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647518468944.png\"\r\nalt=\"enter description here\" /></p></li>\r\n<li><p>点击右上角的'+'号，选择'New repository'跳转到下面的界面 <img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647518514346.png\"\r\nalt=\"enter description here\" /><br />\r\n<strong>Repository name:</strong>\r\n选择-用户名.github.io-的命名格式，之后的site就直接为http://username.github.io\r\n<strong>Public/Private:</strong>\r\n当前创建私有仓库已经免费，如果是个人不想公开的代码和日记等，可以选择Private，已经创建好的仓库也可以转换为另一种权限。\r\n<strong>Initialize this repository with:</strong> 通常会选择'Add a\r\nREADME file'</p></li>\r\n<li><p>创建完毕后，打开仓库，点击⚙setting-Pages，此时界面如下： <img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647519433143.png\"\r\nalt=\"enter description here\" /> <strong>Choose a theme：</strong>\r\n暂时选择一个默认网页模板，之后可以修改为自己喜欢的主题。\r\n至此，一个只有readme文件的空仓库就创建好了。</p></li>\r\n</ol>\r\n<p><strong>参考链接</strong> <a\r\nhref=\"https://www.cnblogs.com/05-hust/articles/13607712.html\">不同权限之间的转换方式</a></p>\r\n<h2 id=\"git安装\">Git安装</h2>\r\n<ol type=\"1\">\r\n<li><p>安装过程参考本节最后的链接，安装好的效果如下： <img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647520903724.png\"\r\nalt=\"enter description here\" /></p></li>\r\n<li><p>打开 Git Bash, 输入git，验证安装是否成功: <img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647520989806.png\"\r\nalt=\"enter description here\" /> ●进行任何操作时，先切换到仓库目录\r\n●声明为Git仓库+信息提交 ==git init #F44336== → 初始化本地git仓库 ==git\r\nadd filename #F44336== → 将file添加到[临时缓冲区] ==git status #F44336==\r\n→ 获取仓库当前的状态 ==git commit -m \"text commit\" #F44336== →\r\n将[临时缓冲区]的内容提交到仓库 ●关于分支的git指令 ==git branch a\r\n#F44336== → 创建分支a ==git checkout a #F44336== → 切换到分支a ==git\r\ncheckout -b a #F44336== → 创建分支a的同时进行切换 ==git merge a\r\n#F44336== → 在主分支下执行，将a分支与主分支进行合并 ==git branch -d/-D a\r\n#F44336== → 删除分支a</p></li>\r\n</ol>\r\n<p><strong>参考链接</strong> <a\r\nhref=\"https://zhuanlan.zhihu.com/p/103325381\">git下载安装指南</a></p>\r\n<h2 id=\"绑定github\">绑定GitHub</h2>\r\n<ol type=\"1\">\r\n<li><p>本地内容怎么投放到github上对应的仓库呢？通过什么协议将本地和自己的github进行绑定呢？\r\n●<strong>利用SSH登录远程主机：</strong> ==method1\r\n#F44336==：口令登录；(需要反复输入密码<br />\r\n==method2 #F44336==: 公钥登录；\r\n●<strong>安全外壳协议(SSH)</strong></p></li>\r\n<li><p><strong>确认本机是否是否安装 SSH</strong> <img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647522852374.png\"\r\nalt=\"enter description here\" /></p></li>\r\n<li><p><strong>生成密钥</strong> ==ssh -keygen -t rsa\r\n#F44336==(通过RSA算法实现) ==id_ras #F44336== → 密钥(本地) ==id_rsa.pub\r\n#F44336== → 公钥(添加到github)</p>\r\n<p>生成文件的所在路径和目录文件如下： <img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647561811480.png\"\r\nalt=\"enter description here\" /></p></li>\r\n<li><p><strong>将公钥添加到自己的github</strong>\r\n●通过找到相应路径，用文本模式打开id_rsa.pub复制其中的内容 ● 直接在git\r\nbash中打开，指令如下 ==$ cd ~/.ssh #F44336== ==$ ls #F44336== ==$ cat\r\nid_rsa.pub #F44336== (注：git中的复制粘贴不是 Ctrl+C 和 Ctrl+V，而是\r\nCtrl+insert 和Shift+insert)</p>\r\n<p>●点击头像-setting-SSH and GPG keys-New SSH key <img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647562157635.png\"\r\nalt=\"enter description here\" /> <img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647563056861.png\"\r\nalt=\"enter description here\" /></p>\r\n<p><strong>Title:</strong> 选填 <strong>Key:</strong>\r\n将公钥文件的内容复制到这里</p></li>\r\n<li><p><strong>验证是否绑定成功</strong> ==ssh -T git@github.com\r\n#F44336== (之后键入yes)</p></li>\r\n</ol>\r\n<h2 id=\"实现提交文件\">实现提交文件</h2>\r\n<ol type=\"1\">\r\n<li><p>基本指令 ==pull #F44336== → 本地 to 远程仓库 ==push #F44336== →\r\n远程仓库 to 本地 example: ==git pull/push origin master #F44336==(branch\r\nname)</p>\r\n<p>●<strong>情况一:当本地没有 git 仓库</strong> a. 直接将远程仓库 clone\r\n到本地(无需通过init进行初始化，并已经自动关联了远程仓库) b. 将文件添加并\r\ncommit 到本地仓库 ==git add #F44336== ==git commit -m \"\" #F44336== c.\r\n将本地仓库的内容push到远程仓库</p>\r\n<p>●<strong>情况二:本地已有Git仓库，并且进行了多次提交</strong> a.\r\n关联远程仓库： ==git remote add origin http:// #F44336== b.\r\n同步远程和本地仓库： ==git pull origin master(this is branch name)\r\n#F44336== c. 新建file ==git add test,txt #F44336== ==git commit -m \"add\r\ntest file\" #F44336== d. 将修改后的内容推到远程仓库： ==git push origin\r\nmaster #F44336==(同上) (注：先pull后push)</p></li>\r\n</ol>\r\n<p><strong>参考文献</strong> <a\r\nhref=\"https://zhuanlan.zhihu.com/p/265454741\">将本仓库更新到远程参考</a>\r\n<a\r\nhref=\"https://zhuanlan.zhihu.com/p/103391101\">两种情况的详细指南</a></p>\r\n<h2 id=\"具体的blog-pages搭建\">具体的BLOG Pages搭建</h2>\r\n<ol type=\"1\">\r\n<li><p><strong>安装nodejs</strong> <a\r\nhref=\"https://nodejs.org/en/\">下载地址</a> <img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647563732842.png\"\r\nalt=\"enter description here\" /></p>\r\n<p>●测试是否安装成功：用 node -v 和 npm -v 命令检查版本 <img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647563776437.png\"\r\nalt=\"enter description here\" /></p>\r\n<p>●关于设置npm在安装全局模块时的路径和环境变量(当没有安装在默认路径)<a\r\nhref=\"https://zhuanlan.zhihu.com/p/105715224\">参考链接</a></p></li>\r\n<li><p><strong>安装Hexo</strong> ● 通过npm安装hexo： ==npm install -g\r\nhexo-cli #F44336== ●输入 ==hexo init #F44336== 命令初始化博客 ●.相关指令\r\n==hexo g #F44336== → 静态部署 ==hexo s #F44336== → 本地预览静态网页\r\n==hexo d #F44336== → 上传网页文件到github</p></li>\r\n<li><p><strong>将博客发布到github上环境配置</strong> ●\r\n配置blog目录中的_config.yml(注意\":\"号后的空格) <img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647564081849.png\"\r\nalt=\"enter description here\" /> <strong>repo:</strong> 目标仓库名\r\n<strong>branch：</strong>\r\n所在分支(注：这里提交的是hexo相关的框架文件，并不是blog目录文件)</p>\r\n<p>●Deployer配置： error : Deployer not find:git reason:\r\n没安装hexo-deployer-git插件 solution: npm install hexo-deployer-git\r\n--save</p>\r\n<p>●输入以下指令： ==hexo clean #F44336== → 清除缓存文件 db.json\r\n和已生成的静态文件 public ==hexo g #F44336== →\r\n生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写) ==hexo\r\nd #F44336== → 自动生成网站静态文件，并部署到设定的仓库(hexo deploy\r\n的缩写)</p>\r\n<p>●配置url <strong>情况一：xxx为用户名</strong> url:\r\nhttp://xxx.github.io root: / <strong>情况二：xxx不是用户名</strong> url:\r\n.../xxx.github.io root: /xxx.github.io</p></li>\r\n</ol>\r\n<p><strong>参考链接</strong> <a\r\nhref=\"https://zhuanlan.zhihu.com/p/127786638\">config.yml文件内容详解</a></p>\r\n<ol start=\"4\" type=\"1\">\r\n<li><strong>主题更换</strong> ●config.yml文件中相关的部分： <img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647564319699.png\"\r\nalt=\"Extensions part\" /> ●themes文件夹中相关的部分：\r\n当前该目录下又两个主题，在config.yml中选择了“fexo”主题 <img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647564488865.png\"\r\nalt=\"enter description here\" /> ●主题配置的过程\r\n<ol type=\"a\">\r\n<li>在下面的hexo主题集合中选择好自己喜欢的主题</li>\r\n<li>打开博客根目录Blog文件夹，右键Git\r\nBash，输入如下代码将目标主题下载到目录Blog/themes： ==git clone (http)\r\nthemes/next #F44336==</li>\r\n<li>修改blog目录下的config.yml文件themes(注意冒号后的空格)</li>\r\n<li>主题页面的修改文件为主题文件内的_config.yml文件，如何修改参鉴clone地址的readme信息</li>\r\n</ol></li>\r\n</ol>\r\n<p><strong>参考链接：</strong> <a\r\nhref=\"https://github.com/FoxerLee/awesome-hexo-themes\">hexo主题集合</a></p>\r\n<h2 id=\"之后要增加的内容\">之后要增加的内容</h2>\r\n<p>==怎么把具体的博客内容发送到自己的pages上\r\n怎么把hexo原代码也发送到远程仓库 其他一些操作指令 小书匠图库的配置 ....\r\n#3F51B5==</p>\r\n","categories":["/小书匠/日记/2022-03"],"tags":["GitHub,blog"]},{"title":"GitHub Page 搭建个人主页","url":"http://example.com/2023/07/26/2022-02-28test/","content":"<p><strong>github\r\nPages——用户编写的、托管在github上的静态网页</strong></p>\r\n<hr />\r\n<h2 id=\"create-personal-repositories\">Create Personal Repositories</h2>\r\n<p>++repository是一个存放项目文件的仓库，之后博客源码和hexo发布后的静态HTML文件全部保存在里面。++</p>\r\n<ol type=\"1\">\r\n<li><p><strong>登录自己的github账号</strong> <img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647518468944.png\"\r\nalt=\"enter description here\" /></p></li>\r\n<li><p><strong>点击右上角的'+'号，选择'New\r\nrepository'跳转到下面的界面</strong> <img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647518514346.png\"\r\nalt=\"enter description here\" /><br />\r\n<strong>Repository name:</strong>\r\n选择-用户名.github.io-的命名格式，之后的site就直接为http://username.github.io\r\n<strong>Public/Private:</strong>\r\n当前创建私有仓库已经免费，如果是个人不想公开的代码和日记等，可以选择Private，已经创建好的仓库也可以转换为另一种权限。\r\n<strong>Initialize this repository with:</strong> 通常会选择'Add a\r\nREADME file'</p></li>\r\n<li><p><strong>创建完毕后，打开仓库，点击⚙setting-Pages，此时界面如下：</strong>\r\n<img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647519433143.png\"\r\nalt=\"enter description here\" /> <strong>Choose a theme：</strong>\r\n暂时选择一个默认网页模板，之后可以修改为自己喜欢的主题。\r\n至此，一个只有readme文件的空仓库就创建好了。</p></li>\r\n</ol>\r\n<p><strong>参考链接</strong> <a\r\nhref=\"https://www.cnblogs.com/05-hust/articles/13607712.html\">不同权限之间的转换方式</a></p>\r\n<hr />\r\n<h2 id=\"git安装\">Git安装</h2>\r\n<ol type=\"1\">\r\n<li><p><strong>安装过程参考本节最后的链接，安装好的效果如下：</strong>\r\n<img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647520903724.png\"\r\nalt=\"enter description here\" /></p></li>\r\n<li><p><strong>打开 Git Bash, 输入git，验证安装是否成功:</strong> <img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647520989806.png\"\r\nalt=\"enter description here\" /> ●进行任何操作时，先切换到仓库目录\r\n●声明为Git仓库+信息提交 <mark>git init</mark> → 初始化本地git仓库\r\n<mark>git add filename</mark> → 将file添加到[临时缓冲区] <mark>git\r\nstatus</mark> → 获取仓库当前的状态 <mark>git commit -m \"text commit\"\r\n</mark> → 将[临时缓冲区]的内容提交到仓库 ●关于分支的git指令 <mark>git\r\nbranch a</mark> → 创建分支a <mark>git checkout a</mark> → 切换到分支a\r\n<mark>git checkout -b a</mark> → 创建分支a的同时进行切换 <mark>git merge\r\na</mark> → 在主分支下执行，将a分支与主分支进行合并 <mark>git branch\r\n-d/-D a</mark> → 删除分支a</p></li>\r\n</ol>\r\n<p><strong>参考链接</strong> <a\r\nhref=\"https://zhuanlan.zhihu.com/p/103325381\">git下载安装指南</a></p>\r\n<hr />\r\n<h2 id=\"绑定github\">绑定GitHub</h2>\r\n<ol type=\"1\">\r\n<li><p><strong>本地内容怎么投放到github上对应的仓库呢？通过什么协议将本地和自己的github进行绑定呢？</strong>\r\n●<strong>利用SSH登录远程主机：</strong>\r\n<mark>method1</mark>：口令登录；(需要反复输入密码<br />\r\n<mark>method2</mark>: 公钥登录；\r\n●<strong>安全外壳协议(SSH)</strong></p></li>\r\n<li><p><strong>确认本机是否是否安装 SSH</strong> <img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647522852374.png\"\r\nalt=\"enter description here\" /></p></li>\r\n<li><p><strong>生成密钥</strong> <mark>ssh -keygen -t\r\nrsa</mark>(通过RSA算法实现) <mark>id_ras</mark> → 密钥(本地)\r\n<mark>id_rsa.pub</mark> → 公钥(添加到github)</p>\r\n<p>生成文件的所在路径和目录文件如下： <img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647561811480.png\"\r\nalt=\"enter description here\" /></p></li>\r\n<li><p><strong>将公钥添加到自己的github</strong>\r\n●通过找到相应路径，用文本模式打开id_rsa.pub复制其中的内容 ● 直接在git\r\nbash中打开，指令如下 <mark>$ cd ~/.ssh</mark> <mark>$ ls</mark> <mark>$\r\ncat id_rsa.pub</mark> (注：git中的复制粘贴不是 Ctrl+C 和 Ctrl+V，而是\r\nCtrl+insert 和Shift+insert)</p>\r\n<p>●点击头像-setting-SSH and GPG keys-New SSH key <img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647562157635.png\"\r\nalt=\"enter description here\" /> <img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647563056861.png\"\r\nalt=\"enter description here\" /></p>\r\n<p><strong>Title:</strong> 选填 <strong>Key:</strong>\r\n将公钥文件的内容复制到这里</p></li>\r\n<li><p><strong>验证是否绑定成功</strong> <mark>ssh -T\r\ngit@github.com</mark> (之后键入yes)</p></li>\r\n</ol>\r\n<hr />\r\n<h2 id=\"实现提交文件\">实现提交文件</h2>\r\n<ol type=\"1\">\r\n<li><p><strong>基本指令</strong> <mark>pull</mark> → 本地 to 远程仓库\r\n<mark>push #F44336</mark> → 远程仓库 to 本地 example: <mark>git\r\npull/push origin master</mark>(branch name)</p>\r\n<p>●<strong>情况一:当本地没有 git 仓库</strong> a. 直接将远程仓库 clone\r\n到本地(无需通过init进行初始化，并已经自动关联了远程仓库) b. 将文件添加并\r\ncommit 到本地仓库 <mark>git add</mark> <mark>git commit -m \"\"</mark> c.\r\n将本地仓库的内容push到远程仓库</p>\r\n<p>●<strong>情况二:本地已有Git仓库，并且进行了多次提交</strong> a.\r\n关联远程仓库： <mark>git remote add origin http:// </mark> b.\r\n同步远程和本地仓库： <mark>git pull origin master(this is branch name)\r\n</mark> c. 新建file <mark>git add test,txt</mark> <mark>git commit -m\r\n\"add test file\"</mark> d. 将修改后的内容推到远程仓库： <mark>git push\r\norigin master</mark>(同上) (注：先pull后push)</p></li>\r\n</ol>\r\n<p><strong>参考文献</strong> <a\r\nhref=\"https://zhuanlan.zhihu.com/p/265454741\">将本仓库更新到远程参考</a>\r\n<a\r\nhref=\"https://zhuanlan.zhihu.com/p/103391101\">两种情况的详细指南</a></p>\r\n<hr />\r\n<h2 id=\"具体的blog-pages搭建\">具体的BLOG Pages搭建</h2>\r\n<ol type=\"1\">\r\n<li><p><strong>安装nodejs</strong> <a\r\nhref=\"https://nodejs.org/en/\">下载地址</a> <img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647563732842.png\"\r\nalt=\"enter description here\" /> ●测试是否安装成功：用 node -v 和 npm -v\r\n命令检查版本 <img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647563776437.png\"\r\nalt=\"enter description here\" />\r\n●关于设置npm在安装全局模块时的路径和环境变量(当没有安装在默认路径)<a\r\nhref=\"https://zhuanlan.zhihu.com/p/105715224\">参考链接</a></p></li>\r\n<li><p><strong>安装Hexo</strong> ● 通过npm安装hexo： <mark>npm install\r\n-g hexo-cli #F44336</mark> ●输入 <mark>hexo init #F44336</mark>\r\n命令初始化博客 ●.相关指令 <mark>hexo g</mark> → 静态部署 <mark>hexo s\r\n</mark> → 本地预览静态网页 <mark>hexo d</mark>→\r\n上传网页文件到github</p></li>\r\n<li><p><strong>将博客发布到github上环境配置</strong> ●\r\n配置blog目录中的_config.yml(注意\":\"号后的空格) <img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647564081849.png\"\r\nalt=\"enter description here\" /> <strong>repo:</strong> 目标仓库名\r\n<strong>branch：</strong>\r\n所在分支(注：这里提交的是hexo相关的框架文件，并不是blog目录文件)</p>\r\n<p>●Deployer配置： error : Deployer not find:git reason:\r\n没安装hexo-deployer-git插件 solution: npm install hexo-deployer-git\r\n--save</p>\r\n<p>●输入以下指令： <mark>hexo clean</mark> → 清除缓存文件 db.json\r\n和已生成的静态文件 public <mark>hexo g</mark>→\r\n生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)\r\n<mark>hexo d</mark> → 自动生成网站静态文件，并部署到设定的仓库(hexo\r\ndeploy 的缩写)</p>\r\n<p>●配置url <strong>情况一：xxx为用户名</strong> url:\r\nhttp://xxx.github.io root: / <strong>情况二：xxx不是用户名</strong> url:\r\n.../xxx.github.io root: /xxx.github.io</p></li>\r\n</ol>\r\n<p><strong>参考链接</strong> <a\r\nhref=\"https://zhuanlan.zhihu.com/p/127786638\">config.yml文件内容详解</a></p>\r\n<ol start=\"4\" type=\"1\">\r\n<li><strong>主题更换</strong> ●config.yml文件中相关的部分： <img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647564319699.png\"\r\nalt=\"Extensions part\" /> ●themes文件夹中相关的部分：\r\n当前该目录下又两个主题，在config.yml中选择了“fexo”主题 <img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647564488865.png\"\r\nalt=\"enter description here\" /> ●主题配置的过程\r\n<ol type=\"a\">\r\n<li>在下面的hexo主题集合中选择好自己喜欢的主题</li>\r\n<li>打开博客根目录Blog文件夹，右键Git\r\nBash，输入如下代码将目标主题下载到目录Blog/themes： <mark>git clone\r\n(http) themes/next</mark></li>\r\n<li>修改blog目录下的config.yml文件themes(注意冒号后的空格)</li>\r\n<li>主题页面的修改文件为主题文件内的_config.yml文件，如何修改参鉴clone地址的readme信息</li>\r\n</ol></li>\r\n</ol>\r\n<p><strong>参考链接：</strong> <a\r\nhref=\"https://github.com/FoxerLee/awesome-hexo-themes\">hexo主题集合</a></p>\r\n<hr />\r\n<h2 id=\"之后要增加的内容\">之后要增加的内容</h2>\r\n<p><mark> 怎么把具体的博客内容发送到自己的pages上\r\n怎么把hexo原代码也发送到远程仓库 其他一些操作指令 小书匠图库的配置 ....\r\n</mark></p>\r\n","categories":["/personal blog/build/2022-03"],"tags":["GitHub,blog"]},{"title":"2022-04-12随机过程笔记","url":"http://example.com/2023/07/26/2022-04-12随机过程笔记/","content":"<h2 id=\"复合possion过程\">复合Possion过程</h2>\r\n<h3 id=\"期望和方差的求解\">期望和方差的求解</h3>\r\n<p><a\r\nhref=\"https://www.wanweibaike.net/wiki-%E5%A4%8D%E5%90%88%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83\">万维百科</a>\r\n<img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1649724853148.png\"\r\nalt=\"enter description here\" /></p>\r\n<h2 id=\"顺序统计量的分布\">顺序统计量的分布</h2>\r\n<h3 id=\"指数分布\">指数分布</h3>\r\n<p><a\r\nhref=\"https://www.docin.com/p-677955576.html\">指数分布顺序统计量的性质</a>\r\n<img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1649731149904.png\"\r\nalt=\"联合概率分布\" /></p>\r\n<h2 id=\"同分布证明题\">同分布证明题</h2>\r\n<h3 id=\"联合概率密度函数的计算\">联合概率密度函数的计算</h3>\r\n<p><a\r\nhref=\"https://www.cnblogs.com/jy333/p/14363780.html\">复合函数联合概率密度函数的计算</a>\r\n<img\r\nsrc=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1649748613496.png\"\r\nalt=\"概率密度转换\" /></p>\r\n","categories":["/小书匠/日记/2022-04"],"tags":["随机过程,数学,笔记"]},{"title":"project","url":"http://example.com/project/index.html","content":"\r\n","categories":[],"tags":[]},{"title":"search","url":"http://example.com/search/index.html","content":"\r\n","categories":[],"tags":[]}]