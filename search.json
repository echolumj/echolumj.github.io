[{"title":"","url":"http://example.com/2023/07/26/光线与几种基本几何的求交/","content":"<h1 id=\"光线与几种基本几何的求交\"><a href=\"#光线与几种基本几何的求交\" class=\"headerlink\" title=\"光线与几种基本几何的求交\"></a><center>光线与几种基本几何的求交</center></h1><p>[toc]</p>\n<h3 id=\"1-光线与二维几何求交\"><a href=\"#1-光线与二维几何求交\" class=\"headerlink\" title=\"1. 光线与二维几何求交\"></a>1. 光线与二维几何求交</h3><h3 id=\"1-光线与平面求交\"><a href=\"#1-光线与平面求交\" class=\"headerlink\" title=\"1) 光线与平面求交\"></a>1) 光线与平面求交</h3><p><img src=\"C:\\Users\\lumanjun\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230726000622333.png\" alt=\"image-20230726000622333\"></p>\n<p>$$<br>\\begin{cases} \\bold P &#x3D; \\bold o + t \\cdot \\bold d \\ \\ \\bold n \\cdot (\\bold P -\\bold P’)&#x3D;0\\end{cases}<br>$$</p>\n<p>$$</p>\n<p>$$</p>\n","categories":[],"tags":[]},{"title":"【Vulkan+Qt】","url":"http://example.com/2023/07/26/【Vulkan+Qt】/","content":"<p>欢迎使用 <strong>{小书匠}(xiaoshujiang)编辑器</strong>，您可以通过 <code>小书匠主按钮&gt;模板</code> 里的模板管理来改变新建文章的内容。</p>\n<p><strong>参考链接</strong><br><a href=\"https://www.bilibili.com/read/cv268059\">enter description here</a></p>\n","categories":["/小书匠/日记/2022-03"],"tags":["新建,模板,小书匠"]},{"title":"《Ray Tracing in One Weekend》 note-1","url":"http://example.com/2023/07/26/《Ray Tracing in One Weekend》note-chart1-2/","content":"<h1 id=\"chart1-2\"><a href=\"#chart1-2\" class=\"headerlink\" title=\"chart1-2\"></a>chart1-2</h1>","categories":[],"tags":[]},{"title":"【Vulkan】将最终绘制结果导出并存储为图片","url":"http://example.com/2023/07/26/【Vulkan】将最终绘制结果导出并存储为图片/","content":"<p>如何将vulkan中绘制的结果导出，并且存储为文件格式？</p>\n<h2 id=\"OpenGL中将绘制结果存储为图片的方法\"><a href=\"#OpenGL中将绘制结果存储为图片的方法\" class=\"headerlink\" title=\"OpenGL中将绘制结果存储为图片的方法\"></a>OpenGL中将绘制结果存储为图片的方法</h2><p>GPU渲染的结果保存在显存(帧缓存)中，想要将保存在显存中的结果转存到内存，在opengl中需要用到glReadPixels这个函数。<br><strong>glReadPixels：</strong> 把已经绘制好的像素（它可能已经被保存到显卡的显存中）读取到内存。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> glReadPixels（GLint x, </span><br><span class=\"line\">\t\t\t\t\tGLint y,       \t   → 左下角坐标</span><br><span class=\"line\">\t\t\t\t\tGLsizei width,</span><br><span class=\"line\">\t\t\t\t\tGLsizei height,    → 前四个参数描述了一个矩形范围</span><br><span class=\"line\">\t\t\t\t\tGLenum format,     → 像素存储的格式</span><br><span class=\"line\">\t\t\t\t\tGLenum type,   \t   → 像素数据的数据类型</span><br><span class=\"line\">\t\t\t\t\tGLvoid * data）;   →返回像素数据</span><br></pre></td></tr></table></figure>\n\n<p><strong>实现过程：</strong><br>step 1：申请一块放置读取到像素的内存</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RGBColor* ColorBuffer = <span class=\"keyword\">new</span> RGBColor[WindowSizeX * WindowSizeY];</span><br></pre></td></tr></table></figure>\n<p>step 2：从显存中读取像素</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">glReadPixels</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, WindowSizeX, WindowSizeY, GL_BGR, GL_UNSIGNED_BYTE, ColorBuffer);</span><br></pre></td></tr></table></figure>\n<p>step 3：将数据写入目标图片文件</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">WriteBMP</span>(<span class=\"string\">&quot;output.bmp&quot;</span>, ColorBuffer, WindowSizeX, WindowSizeY);</span><br></pre></td></tr></table></figure>\n\n<p>step 4：清理申请的内存</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">delete</span>[] ColorBuffer;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注：</strong> 这个存储的过程要放在OpenGL绘制结束后，在交换缓冲之前进行。</p>\n<p><strong>参考链接</strong><br><a href=\"https://blog.csdn.net/cd_yourheart/article/details/123528957\">双缓冲区模式下读取</a><br><a href=\"https://blog.csdn.net/u013412391/article/details/120565095\">将OpenGL渲染的结果保存为图片</a></p>\n<h2 id=\"Vulkan中将绘制结果存储为图片的方法\"><a href=\"#Vulkan中将绘制结果存储为图片的方法\" class=\"headerlink\" title=\"Vulkan中将绘制结果存储为图片的方法\"></a>Vulkan中将绘制结果存储为图片的方法</h2><p><strong>VS opengl：</strong> 基本过程一致，GPU中保存绘制结果的地方→分配得到的内存。但是，opengl中提供了glReadPixels函数，只需要调用这个函数就可以将绘制结果读取出来，但是vulkan中并没有提供直接的函数。</p>\n<p><strong>基本思路：</strong> vulkan中渲染结果放在swapchain image中，程序中往往设定当前swapchain image的数量为物理设备支持的最小swapchain image数量+1,所以要在渲染完之后提交之前，将当前 Swap Chain Image 的内容先存在一块申请的显存上，之后内存映射到内存中。</p>\n<p><strong>1. Format问题</strong><br>    当前物理设备支持的swapchain image的格式为：VK_FORMAT_B8G8R8A8_SRGB<br>    申请到显存的设定格式：VK_FORMAT_R8G8B8A8_SRGB（创建image以及memory的代码如下）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">createImage</span>(WIDTH, HEIGHT, <span class=\"number\">1</span>, VK_IMAGE_TYPE_2D, &gt;&gt;==VK_FORMAT_R8G8B8A8_SRGB==&lt;&lt;, VK_IMAGE_TILING_LINEAR, &gt;&gt;==VK_IMAGE_USAGE_TRANSFER_DST_BIT==&lt;&lt;</span><br><span class=\"line\">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, outputImg, outputImgMemory);</span><br></pre></td></tr></table></figure>\n\n<p><strong>2.Layout问题</strong><br>    当前swap chain Image的布局：VK_IMAGE_LAYOUT_PRESENT_SRC_KHR<br>    作为transfer source的布局：VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL<br>    申请到显存的布局：VK_IMAGE_LAYOUT_UNDEFINED<br>    作为transfer destination的布局：VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL<br>    支持内存映射的布局：VK_IMAGE_LAYOUT_GENERAL<br><strong>3.swap chain image和output image之间布局的转换</strong><br><mark>左图为swap chain Image的布局转换；右图为申请到的显存的布局转换</mark></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD;</span><br><span class=\"line\">   VK_IMAGE_LAYOUT_PRESENT_SRC_KHR--&gt;VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;</span><br><span class=\"line\">   VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL--&gt;VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;</span><br><span class=\"line\"></span><br><span class=\"line\">VK_IMAGE_LAYOUT_UNDEFINED--&gt;VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL--&gt;VK_IMAGE_LAYOUT_GENERAL</span><br></pre></td></tr></table></figure>\n<p><strong>4.swap chain image和output image之间内容的copy</strong><br>     step 1 → Device 是否支持 blitting from optimal tiled images？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> supportsBlit = <span class=\"literal\">true</span>;</span><br><span class=\"line\">VkFormatProperties formatProperties;</span><br><span class=\"line\"><span class=\"built_in\">vkGetPhysicalDeviceFormatProperties</span>(physicalDevice, swapChainImageFormat, &amp;formatProperties);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!(formatProperties.optimalTilingFeatures &amp;  &gt;&gt;==VK_FORMAT_FEATURE_BLIT_SRC_BIT==&lt;&lt;))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstd::cerr &lt;&lt; <span class=\"string\">&quot;Device does not support blitting from optimal tiled images, using copy instead of blit!&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">\tsupportsBlit = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!(formatProperties.linearTilingFeatures &amp; &gt;&gt;==VK_FORMAT_FEATURE_BLIT_DST_BIT==&lt;&lt;)) &#123;</span><br><span class=\"line\">\tstd::cerr &lt;&lt; <span class=\"string\">&quot;Device does not support blitting to linear tiled images, using copy instead of blit!&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">\tsupportsBlit = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>step 2 → Device 支持 blitting from optimal tiled images→<mark>vkCmdBlitImage</mark></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VkOffset3D blitSize;</span><br><span class=\"line\">blitSize.x = width;</span><br><span class=\"line\">blitSize.y = height;</span><br><span class=\"line\">blitSize.z = <span class=\"number\">1</span>;</span><br><span class=\"line\">VkImageBlit imageBlitRegion&#123;&#125;;</span><br><span class=\"line\">imageBlitRegion.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</span><br><span class=\"line\">imageBlitRegion.srcSubresource.layerCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">imageBlitRegion.srcOffsets[<span class=\"number\">1</span>] = blitSize;</span><br><span class=\"line\">imageBlitRegion.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</span><br><span class=\"line\">imageBlitRegion.dstSubresource.layerCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">imageBlitRegion.dstOffsets[<span class=\"number\">1</span>] = blitSize;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Issue the blit command</span></span><br><span class=\"line\"><span class=\"built_in\">vkCmdBlitImage</span>(</span><br><span class=\"line\">\tcommandBuffer,</span><br><span class=\"line\">\tsrcImage, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,</span><br><span class=\"line\">\toutputImg, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,</span><br><span class=\"line\">\t<span class=\"number\">1</span>,</span><br><span class=\"line\">\t&amp;imageBlitRegion,</span><br><span class=\"line\">\tVK_FILTER_NEAREST);</span><br></pre></td></tr></table></figure>\n<p> step 3 → Device 不支持 blitting from optimal tiled images→<mark>vkCmdCopyImage</mark></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VkImageCopy imageCopyRegion&#123;&#125;;</span><br><span class=\"line\">imageCopyRegion.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</span><br><span class=\"line\">imageCopyRegion.srcSubresource.layerCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">imageCopyRegion.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</span><br><span class=\"line\">imageCopyRegion.dstSubresource.layerCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">imageCopyRegion.extent.width = width;</span><br><span class=\"line\">imageCopyRegion.extent.height = height;</span><br><span class=\"line\">imageCopyRegion.extent.depth = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Issue the copy command</span></span><br><span class=\"line\"><span class=\"built_in\">vkCmdCopyImage</span>(</span><br><span class=\"line\">\tcommandBuffer,</span><br><span class=\"line\">\tsrcImage, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,</span><br><span class=\"line\">\toutputImg, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,</span><br><span class=\"line\">\t<span class=\"number\">1</span>,</span><br><span class=\"line\">\t&amp;imageCopyRegion);</span><br></pre></td></tr></table></figure>\n\n<p><strong>5. 进行内存映射，将显存的内容映射到内存</strong><br>    step 1 → 找到subresource 图像数据的起始 offset</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VkImageSubresource subResource&#123; VK_IMAGE_ASPECT_COLOR_BIT, <span class=\"number\">0</span>, <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">VkSubresourceLayout subResourceLayout;</span><br><span class=\"line\"><span class=\"built_in\">vkGetImageSubresourceLayout</span>(logicalDevice, outputImg, &amp;subResource, &amp;subResourceLayout);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Map image memory so we can start copying from it</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* data;</span><br><span class=\"line\">&gt;&gt;==vkMapMemory==&lt;&lt;(logicalDevice, outputImgMemory, <span class=\"number\">0</span>, VK_WHOLE_SIZE, <span class=\"number\">0</span>, (<span class=\"keyword\">void</span>**)&amp;data);</span><br><span class=\"line\">data += subResourceLayout.offset;</span><br></pre></td></tr></table></figure>\n<p><strong>6. 将data数据以ppm格式存入</strong><br><mark>注意点：</mark><br>  若swapchain image格式为BGR，目标存储格式为RGB，则需要手动转换color components</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (colorSwizzle</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">auto</span> a = (<span class=\"keyword\">char</span>*)row;</span><br><span class=\"line\">\t\t<span class=\"keyword\">auto</span> b = (<span class=\"keyword\">char</span>*)(row+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">auto</span> c = (<span class=\"keyword\">char</span>*)(row+<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\tfile.<span class=\"built_in\">write</span>((<span class=\"keyword\">char</span>*)row + <span class=\"number\">2</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tfile.<span class=\"built_in\">write</span>((<span class=\"keyword\">char</span>*)row + <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tfile.<span class=\"built_in\">write</span>((<span class=\"keyword\">char</span>*)row, <span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>参考链接：</strong><br><a href=\"https://gavinkg.github.io/ILearnVulkanFromScratch-CN/mdroot/Vulkan%20%E8%BF%9B%E9%98%B6/%E6%88%AA%E5%8F%96%E5%B1%8F%E5%B9%95/%E5%8E%9F%E7%90%86.html\">截屏原理</a><br><a href=\"https://github.com/SaschaWillems/VulkanCapsViewer/blob/master/vulkancapsviewer.cpp\">代码参考</a></p>\n","categories":["/personal blog/vulkan/2022-03"],"tags":["vulkan,OpenGL"]},{"title":"Hello World","url":"http://example.com/2023/07/26/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","categories":[],"tags":[]},{"title":"GitHub Page 搭建个人主页","url":"http://example.com/2023/07/26/2022-02-28test/","content":"<p><strong>github Pages——用户编写的、托管在github上的静态网页</strong></p>\n<hr>\n<h2 id=\"Create-Personal-Repositories\"><a href=\"#Create-Personal-Repositories\" class=\"headerlink\" title=\"Create Personal Repositories\"></a>Create Personal Repositories</h2><p>++repository是一个存放项目文件的仓库，之后博客源码和hexo发布后的静态HTML文件全部保存在里面。++</p>\n<ol>\n<li><strong>登录自己的github账号</strong><br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647518468944.png\" alt=\"enter description here\"></li>\n<li><strong>点击右上角的’+’号，选择’New repository’跳转到下面的界面</strong><br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647518514346.png\" alt=\"enter description here\"></li>\n</ol>\n<p><strong>Repository name:</strong> 选择-用户名.github.io-的命名格式，之后的site就直接为<a href=\"http://username.github.io/\">http://username.github.io</a><br><strong>Public&#x2F;Private:</strong> 当前创建私有仓库已经免费，如果是个人不想公开的代码和日记等，可以选择Private，已经创建好的仓库也可以转换为另一种权限。<br><strong>Initialize this repository with:</strong> 通常会选择’Add a README file’</p>\n<ol start=\"3\">\n<li><strong>创建完毕后，打开仓库，点击⚙setting-Pages，此时界面如下：</strong><br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647519433143.png\" alt=\"enter description here\"></li>\n</ol>\n<p><strong>Choose a theme：</strong> 暂时选择一个默认网页模板，之后可以修改为自己喜欢的主题。<br>至此，一个只有readme文件的空仓库就创建好了。</p>\n<p><strong>参考链接</strong><br><a href=\"https://www.cnblogs.com/05-hust/articles/13607712.html\">不同权限之间的转换方式</a></p>\n<hr>\n<h2 id=\"Git安装\"><a href=\"#Git安装\" class=\"headerlink\" title=\"Git安装\"></a>Git安装</h2><ol>\n<li><p><strong>安装过程参考本节最后的链接，安装好的效果如下：</strong><br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647520903724.png\" alt=\"enter description here\"></p>\n</li>\n<li><p><strong>打开 Git Bash, 输入git，验证安装是否成功:</strong><br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647520989806.png\" alt=\"enter description here\"><br>●进行任何操作时，先切换到仓库目录<br>●声明为Git仓库+信息提交<br> <mark>git init</mark> → 初始化本地git仓库<br> <mark>git add  filename</mark> → 将file添加到[临时缓冲区]<br> <mark>git status</mark> → 获取仓库当前的状态<br> <mark>git commit -m “text commit” </mark> → 将[临时缓冲区]的内容提交到仓库<br>●关于分支的git指令<br><mark>git branch a</mark> → 创建分支a<br><mark>git checkout a</mark> → 切换到分支a<br><mark>git checkout -b a</mark> → 创建分支a的同时进行切换<br><mark>git merge a</mark> → 在主分支下执行，将a分支与主分支进行合并<br><mark>git branch -d&#x2F;-D a</mark> → 删除分支a</p>\n</li>\n</ol>\n<p><strong>参考链接</strong><br><a href=\"https://zhuanlan.zhihu.com/p/103325381\">git下载安装指南</a></p>\n<hr>\n<h2 id=\"绑定GitHub\"><a href=\"#绑定GitHub\" class=\"headerlink\" title=\"绑定GitHub\"></a>绑定GitHub</h2><ol>\n<li><p><strong>本地内容怎么投放到github上对应的仓库呢？通过什么协议将本地和自己的github进行绑定呢？</strong><br> ●<strong>利用SSH登录远程主机：</strong><br> <mark>method1</mark>：口令登录；(需要反复输入密码<br> <mark>method2</mark>: 公钥登录；<br> ●<strong>安全外壳协议(SSH)</strong></p>\n</li>\n<li><p><strong>确认本机是否是否安装 SSH</strong><br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647522852374.png\" alt=\"enter description here\"></p>\n</li>\n<li><p><strong>生成密钥</strong><br> <mark>ssh -keygen -t rsa</mark>(通过RSA算法实现)<br> <mark>id_ras</mark> → 密钥(本地)<br> <mark>id_rsa.pub</mark> → 公钥(添加到github)</p>\n<p> 生成文件的所在路径和目录文件如下：</p>\n</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647561811480.png\" alt=\"enter description here\"></p>\n<ol start=\"4\">\n<li><strong>将公钥添加到自己的github</strong><br> ●通过找到相应路径，用文本模式打开id_rsa.pub复制其中的内容<br> ● 直接在git bash中打开，指令如下<br> <mark>$ cd ~&#x2F;.ssh</mark><br> <mark>$ ls</mark><br> <mark>$ cat id_rsa.pub</mark><br> (注：git中的复制粘贴不是 Ctrl+C 和 Ctrl+V，而是 Ctrl+insert 和Shift+insert)<br><br> ●点击头像-setting-SSH and GPG keys-New SSH key</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647562157635.png\" alt=\"enter description here\"><br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647563056861.png\" alt=\"enter description here\"></p>\n<p>   <strong>Title:</strong> 选填<br>   <strong>Key:</strong> 将公钥文件的内容复制到这里</p>\n<ol start=\"5\">\n<li><strong>验证是否绑定成功</strong><br><mark>ssh -T <a href=\"mailto:&#103;&#x69;&#116;&#x40;&#103;&#105;&#x74;&#x68;&#x75;&#98;&#46;&#99;&#111;&#x6d;\">&#103;&#x69;&#116;&#x40;&#103;&#105;&#x74;&#x68;&#x75;&#98;&#46;&#99;&#111;&#x6d;</a></mark> (之后键入yes)</li>\n</ol>\n<hr>\n<h2 id=\"实现提交文件\"><a href=\"#实现提交文件\" class=\"headerlink\" title=\"实现提交文件\"></a>实现提交文件</h2><ol>\n<li><p><strong>基本指令</strong><br> <mark>pull</mark> → 本地 to 远程仓库<br> <mark>push #F44336</mark> → 远程仓库 to 本地<br> example: <mark>git pull&#x2F;push origin master</mark>(branch name)</p>\n<p> ●<strong>情况一:当本地没有 git 仓库</strong><br>     a. 直接将远程仓库 clone 到本地(无需通过init进行初始化，并已经自动关联了远程仓库)<br>     b. 将文件添加并 commit 到本地仓库<br>         <mark>git add</mark><br>         <mark>git commit -m “”</mark><br>     c. 将本地仓库的内容push到远程仓库<br><br> ●<strong>情况二:本地已有Git仓库，并且进行了多次提交</strong><br>     a. 关联远程仓库：<br>     <mark>git remote add origin http:&#x2F;&#x2F; </mark><br>     b. 同步远程和本地仓库：<br>     <mark>git pull origin master(this is branch name) </mark><br>     c. 新建file<br>     <mark>git add test,txt</mark><br>     <mark>git commit -m “add test file”</mark><br>     d. 将修改后的内容推到远程仓库：<br>     <mark>git push origin master</mark>(同上)<br>     (注：先pull后push)</p>\n</li>\n</ol>\n<p><strong>参考文献</strong><br><a href=\"https://zhuanlan.zhihu.com/p/265454741\">将本仓库更新到远程参考</a><br><a href=\"https://zhuanlan.zhihu.com/p/103391101\">两种情况的详细指南</a>            </p>\n<hr>\n<h2 id=\"具体的BLOG-Pages搭建\"><a href=\"#具体的BLOG-Pages搭建\" class=\"headerlink\" title=\"具体的BLOG Pages搭建\"></a>具体的BLOG Pages搭建</h2><ol>\n<li><p><strong>安装nodejs</strong><br> <a href=\"https://nodejs.org/en/\">下载地址</a><br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647563732842.png\" alt=\"enter description here\"><br>  ●测试是否安装成功：用 node -v 和 npm -v 命令检查版本<br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647563776437.png\" alt=\"enter description here\"><br> ●关于设置npm在安装全局模块时的路径和环境变量(当没有安装在默认路径)<a href=\"https://zhuanlan.zhihu.com/p/105715224\">参考链接</a></p>\n</li>\n<li><p><strong>安装Hexo</strong><br> ● 通过npm安装hexo：<br> <mark>npm install -g hexo-cli #F44336</mark><br> ●输入 <mark>hexo init #F44336</mark> 命令初始化博客<br> ●.相关指令<br> <mark>hexo g</mark> → 静态部署<br> <mark>hexo s </mark> → 本地预览静态网页<br> <mark>hexo d</mark>→ 上传网页文件到github</p>\n</li>\n<li><p><strong>将博客发布到github上环境配置</strong><br> ● 配置blog目录中的_config.yml(注意”:”号后的空格)<br> <img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647564081849.png\" alt=\"enter description here\"><br> <strong>repo:</strong> 目标仓库名<br> <strong>branch：</strong> 所在分支(注：这里提交的是hexo相关的框架文件，并不是blog目录文件)<br> ●Deployer配置：<br>     error : Deployer not find:git<br>     reason: 没安装hexo-deployer-git插件<br>     solution: npm install hexo-deployer-git –save<br><br> ●输入以下指令：<br>     <mark>hexo clean</mark> → 清除缓存文件 db.json 和已生成的静态文件 public<br>     <mark>hexo g</mark>→ 生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)<br>     <mark>hexo d</mark> → 自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)<br> ●配置url<br> <strong>情况一：xxx为用户名</strong><br>        url: <a href=\"http://xxx.github.io/\">http://xxx.github.io</a><br>        root: &#x2F;<br> <strong>情况二：xxx不是用户名</strong><br>       url: …&#x2F;xxx.github.io<br>       root: &#x2F;xxx.github.io</p>\n</li>\n</ol>\n<p><strong>参考链接</strong><br><a href=\"https://zhuanlan.zhihu.com/p/127786638\">config.yml文件内容详解</a></p>\n<ol start=\"4\">\n<li><strong>主题更换</strong><br> ●config.yml文件中相关的部分：<br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647564319699.png\" alt=\"Extensions part\"><br> ●themes文件夹中相关的部分：<br> 当前该目录下又两个主题，在config.yml中选择了“fexo”主题<br> <img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647564488865.png\" alt=\"enter description here\"><br> ●主题配置的过程<br>  a. 在下面的hexo主题集合中选择好自己喜欢的主题<br>  b. 打开博客根目录Blog文件夹，右键Git Bash，输入如下代码将目标主题下载到目录Blog&#x2F;themes：<br>  <mark>git clone (http) themes&#x2F;next</mark><br>  c. 修改blog目录下的config.yml文件themes(注意冒号后的空格)<br>  d. 主题页面的修改文件为主题文件内的_config.yml文件，如何修改参鉴clone地址的readme信息</li>\n</ol>\n<p><strong>参考链接：</strong><br><a href=\"https://github.com/FoxerLee/awesome-hexo-themes\">hexo主题集合</a></p>\n<hr>\n<h2 id=\"之后要增加的内容\"><a href=\"#之后要增加的内容\" class=\"headerlink\" title=\"之后要增加的内容\"></a>之后要增加的内容</h2><mark>\n怎么把具体的博客内容发送到自己的pages上\n怎么把hexo原代码也发送到远程仓库\n其他一些操作指令\n小书匠图库的配置\n.... \n</mark>\n","categories":["/personal blog/build/2022-03"],"tags":["GitHub,blog"]},{"title":"GitHub Page 搭建个人主页","url":"http://example.com/2023/07/26/2022-03-17未命名文件/","content":"<p><strong>github Pages——用户编写的、托管在github上的静态网页</strong></p>\n<h2 id=\"Create-Personal-Repositories\"><a href=\"#Create-Personal-Repositories\" class=\"headerlink\" title=\"Create Personal Repositories\"></a>Create Personal Repositories</h2><p>++repository是一个存放项目文件的仓库，之后博客源码和hexo发布后的静态HTML文件全部保存在里面。++</p>\n<ol>\n<li>登录自己的github账号<br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647518468944.png\" alt=\"enter description here\"></li>\n<li>点击右上角的’+’号，选择’New repository’跳转到下面的界面<br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647518514346.png\" alt=\"enter description here\"></li>\n</ol>\n<p><strong>Repository name:</strong> 选择-用户名.github.io-的命名格式，之后的site就直接为<a href=\"http://username.github.io/\">http://username.github.io</a><br><strong>Public&#x2F;Private:</strong> 当前创建私有仓库已经免费，如果是个人不想公开的代码和日记等，可以选择Private，已经创建好的仓库也可以转换为另一种权限。<br><strong>Initialize this repository with:</strong> 通常会选择’Add a README file’</p>\n<ol start=\"3\">\n<li>创建完毕后，打开仓库，点击⚙setting-Pages，此时界面如下：<br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647519433143.png\" alt=\"enter description here\"></li>\n</ol>\n<p><strong>Choose a theme：</strong> 暂时选择一个默认网页模板，之后可以修改为自己喜欢的主题。<br>至此，一个只有readme文件的空仓库就创建好了。</p>\n<p><strong>参考链接</strong><br><a href=\"https://www.cnblogs.com/05-hust/articles/13607712.html\">不同权限之间的转换方式</a></p>\n<h2 id=\"Git安装\"><a href=\"#Git安装\" class=\"headerlink\" title=\"Git安装\"></a>Git安装</h2><ol>\n<li><p>安装过程参考本节最后的链接，安装好的效果如下：<br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647520903724.png\" alt=\"enter description here\"></p>\n</li>\n<li><p>打开 Git Bash, 输入git，验证安装是否成功:<br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647520989806.png\" alt=\"enter description here\"><br>●进行任何操作时，先切换到仓库目录<br>●声明为Git仓库+信息提交<br> &#x3D;&#x3D;git init #F44336&#x3D;&#x3D; → 初始化本地git仓库<br>&#x3D;&#x3D;git add  filename #F44336&#x3D;&#x3D; → 将file添加到[临时缓冲区]<br> &#x3D;&#x3D;git status #F44336&#x3D;&#x3D; → 获取仓库当前的状态<br> &#x3D;&#x3D;git commit -m “text commit” #F44336&#x3D;&#x3D; → 将[临时缓冲区]的内容提交到仓库<br>●关于分支的git指令<br>&#x3D;&#x3D;git branch a #F44336&#x3D;&#x3D; → 创建分支a<br>&#x3D;&#x3D;git checkout a #F44336&#x3D;&#x3D; → 切换到分支a<br>&#x3D;&#x3D;git checkout -b a #F44336&#x3D;&#x3D; → 创建分支a的同时进行切换<br>&#x3D;&#x3D;git merge a #F44336&#x3D;&#x3D; → 在主分支下执行，将a分支与主分支进行合并<br>&#x3D;&#x3D;git branch -d&#x2F;-D a #F44336&#x3D;&#x3D; → 删除分支a</p>\n</li>\n</ol>\n<p><strong>参考链接</strong><br><a href=\"https://zhuanlan.zhihu.com/p/103325381\">git下载安装指南</a></p>\n<h2 id=\"绑定GitHub\"><a href=\"#绑定GitHub\" class=\"headerlink\" title=\"绑定GitHub\"></a>绑定GitHub</h2><ol>\n<li><p>本地内容怎么投放到github上对应的仓库呢？通过什么协议将本地和自己的github进行绑定呢？<br> ●<strong>利用SSH登录远程主机：</strong><br> &#x3D;&#x3D;method1 #F44336&#x3D;&#x3D;：口令登录；(需要反复输入密码<br> &#x3D;&#x3D;method2 #F44336&#x3D;&#x3D;: 公钥登录；<br> ●<strong>安全外壳协议(SSH)</strong></p>\n</li>\n<li><p><strong>确认本机是否是否安装 SSH</strong><br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647522852374.png\" alt=\"enter description here\"></p>\n</li>\n<li><p><strong>生成密钥</strong><br> &#x3D;&#x3D;ssh -keygen -t rsa #F44336&#x3D;&#x3D;(通过RSA算法实现)<br> &#x3D;&#x3D;id_ras #F44336&#x3D;&#x3D; → 密钥(本地)<br> &#x3D;&#x3D;id_rsa.pub #F44336&#x3D;&#x3D; → 公钥(添加到github)</p>\n<p> 生成文件的所在路径和目录文件如下：</p>\n</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647561811480.png\" alt=\"enter description here\"></p>\n<ol start=\"4\">\n<li><strong>将公钥添加到自己的github</strong><br> ●通过找到相应路径，用文本模式打开id_rsa.pub复制其中的内容<br> ● 直接在git bash中打开，指令如下<br> &#x3D;&#x3D;$ cd ~&#x2F;.ssh #F44336&#x3D;&#x3D;<br> &#x3D;&#x3D;$ ls #F44336&#x3D;&#x3D;<br> &#x3D;&#x3D;$ cat id_rsa.pub #F44336&#x3D;&#x3D;<br> (注：git中的复制粘贴不是 Ctrl+C 和 Ctrl+V，而是 Ctrl+insert 和Shift+insert)<br><br> ●点击头像-setting-SSH and GPG keys-New SSH key</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647562157635.png\" alt=\"enter description here\"><br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647563056861.png\" alt=\"enter description here\"></p>\n<p>   <strong>Title:</strong> 选填<br>   <strong>Key:</strong> 将公钥文件的内容复制到这里</p>\n<ol start=\"5\">\n<li><strong>验证是否绑定成功</strong><br> &#x3D;&#x3D;ssh -T <a href=\"mailto:&#x67;&#x69;&#x74;&#x40;&#x67;&#x69;&#x74;&#104;&#x75;&#98;&#46;&#x63;&#x6f;&#109;\">&#x67;&#x69;&#x74;&#x40;&#x67;&#x69;&#x74;&#104;&#x75;&#98;&#46;&#x63;&#x6f;&#109;</a> #F44336&#x3D;&#x3D; (之后键入yes)</li>\n</ol>\n<h2 id=\"实现提交文件\"><a href=\"#实现提交文件\" class=\"headerlink\" title=\"实现提交文件\"></a>实现提交文件</h2><ol>\n<li><p>基本指令<br> &#x3D;&#x3D;pull #F44336&#x3D;&#x3D; → 本地 to 远程仓库<br> &#x3D;&#x3D;push #F44336&#x3D;&#x3D; → 远程仓库 to 本地<br> example: &#x3D;&#x3D;git pull&#x2F;push origin master #F44336&#x3D;&#x3D;(branch name)</p>\n<p> ●<strong>情况一:当本地没有 git 仓库</strong><br>     a. 直接将远程仓库 clone 到本地(无需通过init进行初始化，并已经自动关联了远程仓库)<br>     b. 将文件添加并 commit 到本地仓库<br>               &#x3D;&#x3D;git add #F44336&#x3D;&#x3D;<br>             &#x3D;&#x3D;git commit -m “” #F44336&#x3D;&#x3D;<br>     c. 将本地仓库的内容push到远程仓库<br><br> ●<strong>情况二:本地已有Git仓库，并且进行了多次提交</strong><br>     a. 关联远程仓库：<br>         &#x3D;&#x3D;git remote add origin http:&#x2F;&#x2F; #F44336&#x3D;&#x3D;<br>     b. 同步远程和本地仓库：<br>         &#x3D;&#x3D;git pull origin master(this is branch name) #F44336&#x3D;&#x3D;<br>     c. 新建file<br>         &#x3D;&#x3D;git add test,txt #F44336&#x3D;&#x3D;<br>         &#x3D;&#x3D;git commit -m “add test file” #F44336&#x3D;&#x3D;<br>     d. 将修改后的内容推到远程仓库：<br>         &#x3D;&#x3D;git push origin master #F44336&#x3D;&#x3D;(同上)<br>     (注：先pull后push)</p>\n</li>\n</ol>\n<p><strong>参考文献</strong><br><a href=\"https://zhuanlan.zhihu.com/p/265454741\">将本仓库更新到远程参考</a><br><a href=\"https://zhuanlan.zhihu.com/p/103391101\">两种情况的详细指南</a>            </p>\n<h2 id=\"具体的BLOG-Pages搭建\"><a href=\"#具体的BLOG-Pages搭建\" class=\"headerlink\" title=\"具体的BLOG Pages搭建\"></a>具体的BLOG Pages搭建</h2><ol>\n<li><p><strong>安装nodejs</strong><br> <a href=\"https://nodejs.org/en/\">下载地址</a><br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647563732842.png\" alt=\"enter description here\"></p>\n<p> ●测试是否安装成功：用 node -v 和 npm -v 命令检查版本</p>\n</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647563776437.png\" alt=\"enter description here\"></p>\n<pre><code>●关于设置npm在安装全局模块时的路径和环境变量(当没有安装在默认路径)[参考链接](https://zhuanlan.zhihu.com/p/105715224)\n    \n</code></pre>\n<ol start=\"2\">\n<li><p><strong>安装Hexo</strong><br> ● 通过npm安装hexo：<br> &#x3D;&#x3D;npm install -g hexo-cli #F44336&#x3D;&#x3D;<br> ●输入 &#x3D;&#x3D;hexo init #F44336&#x3D;&#x3D; 命令初始化博客<br> ●.相关指令<br> &#x3D;&#x3D;hexo g #F44336&#x3D;&#x3D; → 静态部署<br> &#x3D;&#x3D;hexo s #F44336&#x3D;&#x3D; → 本地预览静态网页<br> &#x3D;&#x3D;hexo d #F44336&#x3D;&#x3D; → 上传网页文件到github</p>\n</li>\n<li><p><strong>将博客发布到github上环境配置</strong><br> ● 配置blog目录中的_config.yml(注意”:”号后的空格)<br> <img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647564081849.png\" alt=\"enter description here\"><br> <strong>repo:</strong> 目标仓库名<br> <strong>branch：</strong> 所在分支(注：这里提交的是hexo相关的框架文件，并不是blog目录文件)<br> ●Deployer配置：<br>     error : Deployer not find:git<br>     reason: 没安装hexo-deployer-git插件<br>     solution: npm install hexo-deployer-git –save<br><br> ●输入以下指令：<br>     &#x3D;&#x3D;hexo clean #F44336&#x3D;&#x3D; → 清除缓存文件 db.json 和已生成的静态文件 public<br>     &#x3D;&#x3D;hexo g #F44336&#x3D;&#x3D; → 生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)<br>     &#x3D;&#x3D;hexo d #F44336&#x3D;&#x3D; → 自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)<br> ●配置url<br> <strong>情况一：xxx为用户名</strong><br>        url: <a href=\"http://xxx.github.io/\">http://xxx.github.io</a><br>        root: &#x2F;<br> <strong>情况二：xxx不是用户名</strong><br>       url: …&#x2F;xxx.github.io<br>       root: &#x2F;xxx.github.io</p>\n</li>\n</ol>\n<p><strong>参考链接</strong><br><a href=\"https://zhuanlan.zhihu.com/p/127786638\">config.yml文件内容详解</a></p>\n<ol start=\"4\">\n<li><strong>主题更换</strong><br> ●config.yml文件中相关的部分：<br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647564319699.png\" alt=\"Extensions part\"><br> ●themes文件夹中相关的部分：<br> 当前该目录下又两个主题，在config.yml中选择了“fexo”主题<br> <img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647564488865.png\" alt=\"enter description here\"><br> ●主题配置的过程<br>  a. 在下面的hexo主题集合中选择好自己喜欢的主题<br>  b. 打开博客根目录Blog文件夹，右键Git Bash，输入如下代码将目标主题下载到目录Blog&#x2F;themes：<br> &#x3D;&#x3D;git clone (http) themes&#x2F;next #F44336&#x3D;&#x3D;<br>  c. 修改blog目录下的config.yml文件themes(注意冒号后的空格)<br>  d. 主题页面的修改文件为主题文件内的_config.yml文件，如何修改参鉴clone地址的readme信息</li>\n</ol>\n<p><strong>参考链接：</strong><br><a href=\"https://github.com/FoxerLee/awesome-hexo-themes\">hexo主题集合</a></p>\n<h2 id=\"之后要增加的内容\"><a href=\"#之后要增加的内容\" class=\"headerlink\" title=\"之后要增加的内容\"></a>之后要增加的内容</h2><p>&#x3D;&#x3D;怎么把具体的博客内容发送到自己的pages上<br>怎么把hexo原代码也发送到远程仓库<br>其他一些操作指令<br>小书匠图库的配置<br>…. #3F51B5&#x3D;&#x3D;</p>\n","categories":["/小书匠/日记/2022-03"],"tags":["GitHub,blog"]},{"title":"2022-04-12随机过程笔记","url":"http://example.com/2023/07/26/2022-04-12随机过程笔记/","content":"<h2 id=\"复合Possion过程\"><a href=\"#复合Possion过程\" class=\"headerlink\" title=\"复合Possion过程\"></a>复合Possion过程</h2><h3 id=\"期望和方差的求解\"><a href=\"#期望和方差的求解\" class=\"headerlink\" title=\"期望和方差的求解\"></a>期望和方差的求解</h3><p><a href=\"https://www.wanweibaike.net/wiki-%E5%A4%8D%E5%90%88%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83\">万维百科</a><br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1649724853148.png\" alt=\"enter description here\"></p>\n<h2 id=\"顺序统计量的分布\"><a href=\"#顺序统计量的分布\" class=\"headerlink\" title=\"顺序统计量的分布\"></a>顺序统计量的分布</h2><h3 id=\"指数分布\"><a href=\"#指数分布\" class=\"headerlink\" title=\"指数分布\"></a>指数分布</h3><p><a href=\"https://www.docin.com/p-677955576.html\">指数分布顺序统计量的性质</a><br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1649731149904.png\" alt=\"联合概率分布\"></p>\n<h2 id=\"同分布证明题\"><a href=\"#同分布证明题\" class=\"headerlink\" title=\"同分布证明题\"></a>同分布证明题</h2><h3 id=\"联合概率密度函数的计算\"><a href=\"#联合概率密度函数的计算\" class=\"headerlink\" title=\"联合概率密度函数的计算\"></a>联合概率密度函数的计算</h3><p><a href=\"https://www.cnblogs.com/jy333/p/14363780.html\">复合函数联合概率密度函数的计算</a><br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1649748613496.png\" alt=\"概率密度转换\"></p>\n","categories":["/小书匠/日记/2022-04"],"tags":["随机过程,数学,笔记"]},{"title":"GitHub Page 搭建个人主页","url":"http://example.com/2023/07/26/GitHub Page 搭建个人主页/","content":"<p><strong>github Pages——用户编写的、托管在github上的静态网页</strong></p>\n<hr>\n<h2 id=\"Create-Personal-Repositories\"><a href=\"#Create-Personal-Repositories\" class=\"headerlink\" title=\"Create Personal Repositories\"></a>Create Personal Repositories</h2><p>++repository是一个存放项目文件的仓库，之后博客源码和hexo发布后的静态HTML文件全部保存在里面。++</p>\n<ol>\n<li><strong>登录自己的github账号</strong><br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647518468944.png\" alt=\"enter description here\"></li>\n<li><strong>点击右上角的’+’号，选择’New repository’跳转到下面的界面</strong><br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647518514346.png\" alt=\"enter description here\"></li>\n</ol>\n<p><strong>Repository name:</strong> 选择-用户名.github.io-的命名格式，之后的site就直接为<a href=\"http://username.github.io/\">http://username.github.io</a><br><strong>Public&#x2F;Private:</strong> 当前创建私有仓库已经免费，如果是个人不想公开的代码和日记等，可以选择Private，已经创建好的仓库也可以转换为另一种权限。<br><strong>Initialize this repository with:</strong> 通常会选择’Add a README file’</p>\n<ol start=\"3\">\n<li><strong>创建完毕后，打开仓库，点击⚙setting-Pages，此时界面如下：</strong><br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647519433143.png\" alt=\"enter description here\"></li>\n</ol>\n<p><strong>Choose a theme：</strong> 暂时选择一个默认网页模板，之后可以修改为自己喜欢的主题。<br>至此，一个只有readme文件的空仓库就创建好了。</p>\n<p><strong>参考链接</strong><br><a href=\"https://www.cnblogs.com/05-hust/articles/13607712.html\">不同权限之间的转换方式</a></p>\n<hr>\n<h2 id=\"Git安装\"><a href=\"#Git安装\" class=\"headerlink\" title=\"Git安装\"></a>Git安装</h2><ol>\n<li><p><strong>安装过程参考本节最后的链接，安装好的效果如下：</strong><br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647520903724.png\" alt=\"enter description here\"></p>\n</li>\n<li><p><strong>打开 Git Bash, 输入git，验证安装是否成功:</strong><br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647520989806.png\" alt=\"enter description here\"><br>●进行任何操作时，先切换到仓库目录<br>●声明为Git仓库+信息提交<br> <mark>git init</mark> → 初始化本地git仓库<br> <mark>git add  filename</mark> → 将file添加到[临时缓冲区]<br> <mark>git status</mark> → 获取仓库当前的状态<br> <mark>git commit -m “text commit” </mark> → 将[临时缓冲区]的内容提交到仓库<br>●关于分支的git指令<br><mark>git branch a</mark> → 创建分支a<br><mark>git checkout a</mark> → 切换到分支a<br><mark>git checkout -b a</mark> → 创建分支a的同时进行切换<br><mark>git merge a</mark> → 在主分支下执行，将a分支与主分支进行合并<br><mark>git branch -d&#x2F;-D a</mark> → 删除分支a</p>\n</li>\n</ol>\n<p><strong>参考链接</strong><br><a href=\"https://zhuanlan.zhihu.com/p/103325381\">git下载安装指南</a></p>\n<hr>\n<h2 id=\"绑定GitHub\"><a href=\"#绑定GitHub\" class=\"headerlink\" title=\"绑定GitHub\"></a>绑定GitHub</h2><ol>\n<li><p><strong>本地内容怎么投放到github上对应的仓库呢？通过什么协议将本地和自己的github进行绑定呢？</strong><br> ●<strong>利用SSH登录远程主机：</strong><br> <mark>method1</mark>：口令登录；(需要反复输入密码<br> <mark>method2</mark>: 公钥登录；<br> ●<strong>安全外壳协议(SSH)</strong></p>\n</li>\n<li><p><strong>确认本机是否是否安装 SSH</strong><br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647522852374.png\" alt=\"enter description here\"></p>\n</li>\n<li><p><strong>生成密钥</strong><br> <mark>ssh -keygen -t rsa</mark>(通过RSA算法实现)<br> <mark>id_ras</mark> → 密钥(本地)<br> <mark>id_rsa.pub</mark> → 公钥(添加到github)</p>\n<p> 生成文件的所在路径和目录文件如下：</p>\n</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647561811480.png\" alt=\"enter description here\"></p>\n<ol start=\"4\">\n<li><strong>将公钥添加到自己的github</strong><br> ●通过找到相应路径，用文本模式打开id_rsa.pub复制其中的内容<br> ● 直接在git bash中打开，指令如下<br> <mark>$ cd ~&#x2F;.ssh</mark><br> <mark>$ ls</mark><br> <mark>$ cat id_rsa.pub</mark><br> (注：git中的复制粘贴不是 Ctrl+C 和 Ctrl+V，而是 Ctrl+insert 和Shift+insert)<br><br> ●点击头像-setting-SSH and GPG keys-New SSH key</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647562157635.png\" alt=\"enter description here\"><br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647563056861.png\" alt=\"enter description here\"></p>\n<p>   <strong>Title:</strong> 选填<br>   <strong>Key:</strong> 将公钥文件的内容复制到这里</p>\n<ol start=\"5\">\n<li><strong>验证是否绑定成功</strong><br><mark>ssh -T <a href=\"mailto:&#103;&#105;&#x74;&#x40;&#x67;&#105;&#x74;&#104;&#117;&#x62;&#x2e;&#99;&#x6f;&#x6d;\">&#103;&#105;&#x74;&#x40;&#x67;&#105;&#x74;&#104;&#117;&#x62;&#x2e;&#99;&#x6f;&#x6d;</a></mark> (之后键入yes)</li>\n</ol>\n<hr>\n<h2 id=\"实现提交文件\"><a href=\"#实现提交文件\" class=\"headerlink\" title=\"实现提交文件\"></a>实现提交文件</h2><ol>\n<li><p><strong>基本指令</strong><br> <mark>pull</mark> → 本地 to 远程仓库<br> <mark>push #F44336</mark> → 远程仓库 to 本地<br> example: <mark>git pull&#x2F;push origin master</mark>(branch name)</p>\n<p> ●<strong>情况一:当本地没有 git 仓库</strong><br>     a. 直接将远程仓库 clone 到本地(无需通过init进行初始化，并已经自动关联了远程仓库)<br>     b. 将文件添加并 commit 到本地仓库<br>         <mark>git add</mark><br>         <mark>git commit -m “”</mark><br>     c. 将本地仓库的内容push到远程仓库<br><br> ●<strong>情况二:本地已有Git仓库，并且进行了多次提交</strong><br>     a. 关联远程仓库：<br>     <mark>git remote add origin http:&#x2F;&#x2F; </mark><br>     b. 同步远程和本地仓库：<br>     <mark>git pull origin master(this is branch name) </mark><br>     c. 新建file<br>     <mark>git add test,txt</mark><br>     <mark>git commit -m “add test file”</mark><br>     d. 将修改后的内容推到远程仓库：<br>     <mark>git push origin master</mark>(同上)<br>     (注：先pull后push)</p>\n</li>\n</ol>\n<p><strong>参考文献</strong><br><a href=\"https://zhuanlan.zhihu.com/p/265454741\">将本仓库更新到远程参考</a><br><a href=\"https://zhuanlan.zhihu.com/p/103391101\">两种情况的详细指南</a>            </p>\n<hr>\n<h2 id=\"具体的BLOG-Pages搭建\"><a href=\"#具体的BLOG-Pages搭建\" class=\"headerlink\" title=\"具体的BLOG Pages搭建\"></a>具体的BLOG Pages搭建</h2><ol>\n<li><p><strong>安装nodejs</strong><br> <a href=\"https://nodejs.org/en/\">下载地址</a><br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647563732842.png\" alt=\"enter description here\"><br>  ●测试是否安装成功：用 node -v 和 npm -v 命令检查版本<br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647563776437.png\" alt=\"enter description here\"><br> ●关于设置npm在安装全局模块时的路径和环境变量(当没有安装在默认路径)<a href=\"https://zhuanlan.zhihu.com/p/105715224\">参考链接</a></p>\n</li>\n<li><p><strong>安装Hexo</strong><br> ● 通过npm安装hexo：<br> <mark>npm install -g hexo-cli #F44336</mark><br> ●输入 <mark>hexo init #F44336</mark> 命令初始化博客<br> ●.相关指令<br> <mark>hexo g</mark> → 静态部署<br> <mark>hexo s </mark> → 本地预览静态网页<br> <mark>hexo d</mark>→ 上传网页文件到github</p>\n</li>\n<li><p><strong>将博客发布到github上环境配置</strong><br> ● 配置blog目录中的_config.yml(注意”:”号后的空格)<br> <img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647564081849.png\" alt=\"enter description here\"><br> <strong>repo:</strong> 目标仓库名<br> <strong>branch：</strong> 所在分支(注：这里提交的是hexo相关的框架文件，并不是blog目录文件)<br> ●Deployer配置：<br>     error : Deployer not find:git<br>     reason: 没安装hexo-deployer-git插件<br>     solution: npm install hexo-deployer-git –save<br><br> ●输入以下指令：<br>     <mark>hexo clean</mark> → 清除缓存文件 db.json 和已生成的静态文件 public<br>     <mark>hexo g</mark>→ 生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)<br>     <mark>hexo d</mark> → 自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)<br> ●配置url<br> <strong>情况一：xxx为用户名</strong><br>        url: <a href=\"http://xxx.github.io/\">http://xxx.github.io</a><br>        root: &#x2F;<br> <strong>情况二：xxx不是用户名</strong><br>       url: …&#x2F;xxx.github.io<br>       root: &#x2F;xxx.github.io</p>\n</li>\n</ol>\n<p><strong>参考链接</strong><br><a href=\"https://zhuanlan.zhihu.com/p/127786638\">config.yml文件内容详解</a></p>\n<ol start=\"4\">\n<li><strong>主题更换</strong><br> ●config.yml文件中相关的部分：<br><img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647564319699.png\" alt=\"Extensions part\"><br> ●themes文件夹中相关的部分：<br> 当前该目录下又两个主题，在config.yml中选择了“fexo”主题<br> <img src=\"https://raw.githubusercontent.com/echolumj/blogImg/main/blog/1647564488865.png\" alt=\"enter description here\"><br> ●主题配置的过程<br>  a. 在下面的hexo主题集合中选择好自己喜欢的主题<br>  b. 打开博客根目录Blog文件夹，右键Git Bash，输入如下代码将目标主题下载到目录Blog&#x2F;themes：<br>  <mark>git clone (http) themes&#x2F;next</mark><br>  c. 修改blog目录下的config.yml文件themes(注意冒号后的空格)<br>  d. 主题页面的修改文件为主题文件内的_config.yml文件，如何修改参鉴clone地址的readme信息</li>\n</ol>\n<p><strong>参考链接：</strong><br><a href=\"https://github.com/FoxerLee/awesome-hexo-themes\">hexo主题集合</a></p>\n<hr>\n<h2 id=\"之后要增加的内容\"><a href=\"#之后要增加的内容\" class=\"headerlink\" title=\"之后要增加的内容\"></a>之后要增加的内容</h2><mark>\n怎么把具体的博客内容发送到自己的pages上\n怎么把hexo原代码也发送到远程仓库\n其他一些操作指令\n小书匠图库的配置\n.... \n</mark>\n","categories":["/personal blog/build/2022-03"],"tags":["GitHub,blog"]},{"title":"search","url":"http://example.com/search/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"http://example.com/project/index.html","content":"","categories":[],"tags":[]}]